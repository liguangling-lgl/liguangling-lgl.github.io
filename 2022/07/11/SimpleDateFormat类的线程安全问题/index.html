


<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>  SimpleDateFormat类线程安全问题 |    liguangling的博客</title>
  <meta name="description" content="A minimalist theme for hexo.">
  <!-- 标签页图标 -->
  

  <!-- 图标库 -->
  <link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
  <!-- 动画库 -->
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fushaolei/cdn-white@1.0/css/animate.css"/>
  
  <!-- css文件 -->
  
<link rel="stylesheet" href="/css/white.css">

  <!-- 代码高亮 -->
  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>

<div class="menu-outer">
    <div class="menu-inner">
      <div class="menu-site-name  animate__animated  animate__fadeInUp">
        <a href="/">
          liguangling的博客
        </a>
        
      </div>
      <div class="menu-group">
        <ul class="menu-ul">
        
          <a href="/archives" class="nav-link">
            <li class="menu-li  animate__animated  animate__fadeInUp">
              BLOG
            </li>
          </a>
        
        
        
          <li class="menu-li animate__animated  animate__fadeInUp" id="mobile-menu">
            <i class="ri-menu-line"></i>
          </li>
        
        </ul>

      </div>

    </div>
</div>
<div id="mobile-main" class="animate__animated  animate__fadeIn">
  <div class="mobile-menu-inner">
    <div class="mobile-menu-site-name animate__animated  animate__fadeInUp">
      <a href="/">
        liguangling的博客
      </a>
    </div>
    <div class="mobile-menu-group" id="mobile-close">
      <i class="ri-close-line"></i>
    </div>

  </div>

  <div class="mobile-menu-div">
  
    <a href="/archives" class="mobile-nav-link">
      <div class="mobile-menu-child animate__animated  animate__fadeInUp">
        <span>BLOG</span>
      </div>
    </a>
  
  
  </div>


</div>

<div class="body-outer">
  <div class="body-inner">
    
<article class="post-inner">
  <div class="post-content-outer">
    <div class="post-intro">
      <div class="post-title animate__animated  animate__fadeInUp">SimpleDateFormat类线程安全问题</div>
      <div class="meta-intro animate__animated  animate__fadeInUp">Jul 11 2022</div>
      
    </div>
    <div class="post-content-inner">
      <div class="post-content-inner-space">

      </div>
      <div class="post-content-main animate__animated  animate__fadeInUp">
        <!-- top型目录 -->
        
        <p>在高并发下SimpleDateFormat类为何会出现安全问题，以及如何解决<br>SimpleDateFormat类的安全问题。</p>
<h4 id="重现SimpleDateFormat类的线程安全问题"><a href="#重现SimpleDateFormat类的线程安全问题" class="headerlink" title="重现SimpleDateFormat类的线程安全问题"></a>重现SimpleDateFormat类的线程安全问题</h4><p>为了重现SimpleDateFormat类的线程安全问题，一种比较简单的方式就是使用线程池结合Java并发包<br>中的CountDownLatch类和Semaphore类来重现线程安全问题。CountDownLatch类可以使一个线程等待其他线程各自执行完毕后再执行。而Semaphore类可以理解为一个计数信号量，必须由获取它的线程释放，经常用来限制访问某些资源的线程数量，例如限流等</p>
<p>好了，先来看下重现SimpleDateFormat类的线程安全问题的代码，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package io.binghe.concurrent.lab06;</span><br><span class="line">import java.text.ParseException; </span><br><span class="line">import java.text.SimpleDateFormat; </span><br><span class="line">import java.util.concurrent.CountDownLatch; </span><br><span class="line">import java.util.concurrent.ExecutorService; </span><br><span class="line">import java.util.concurrent.Executors; import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*** @author binghe </span><br><span class="line">  * @version 1.0.0</span><br><span class="line">  * @description 测试SimpleDateFormat的线程不安全问题 </span><br><span class="line">  */</span><br><span class="line">  public class SimpleDateFormatTest01 &#123; </span><br><span class="line">  //执行总次数</span><br><span class="line">  private static final int EXECUTE_COUNT = 1000; //同时运行的线程数量 private static final int THREAD_COUNT = 20; //SimpleDateFormat对象</span><br><span class="line">  </span><br><span class="line">  private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); </span><br><span class="line">  </span><br><span class="line">  public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">  </span><br><span class="line">  final Semaphore semaphore = new Semaphore(THREAD_COUNT); </span><br><span class="line">  </span><br><span class="line">  final CountDownLatch countDownLatch = new CountDownLatch(EXECUTE_COUNT);</span><br><span class="line">  </span><br><span class="line">  ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">  </span><br><span class="line">  for (int i = 0; i &lt; EXECUTE_COUNT; i++)&#123; </span><br><span class="line">          executorService.execute(() -&gt; &#123; </span><br><span class="line">          </span><br><span class="line">              try &#123;</span><br><span class="line">                 semaphore.acquire(); </span><br><span class="line">                 try &#123;</span><br><span class="line">                   simpleDateFormat.parse(&quot;2020-01-01&quot;);</span><br><span class="line">                   </span><br><span class="line">               &#125; catch (ParseException e) &#123; </span><br><span class="line">               </span><br><span class="line">               System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;); e.printStackTrace(); System.exit(1);</span><br><span class="line">               </span><br><span class="line">               &#125;catch (NumberFormatException e)&#123;</span><br><span class="line">               </span><br><span class="line">               System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">               </span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               System.exit(1); </span><br><span class="line">                   </span><br><span class="line">               &#125;</span><br><span class="line">               semaphore.release();</span><br><span class="line">               </span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               </span><br><span class="line">               System.out.println(&quot;信号量发生错误&quot;);</span><br><span class="line">               e.printStackTrace(); </span><br><span class="line">               System.exit(1); </span><br><span class="line">                   </span><br><span class="line">               &#125;</span><br><span class="line">               countDownLatch.countDown(); </span><br><span class="line">              </span><br><span class="line">          &#125;); </span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  countDownLatch.await(); </span><br><span class="line">  executorService.shutdown();</span><br><span class="line">  System.out.println(&quot;所有线程格式化日期成功&quot;); &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在SimpleDateFormatTest01类中，首先定义了两个常量，一个是程序执行的总次数，一个<br>是同时运行的线程数量。程序中结合线程池和CountDownLatch类与Semaphore类来模拟高并发的业<br>务场景。其中，有关日期转化的代码只有如下一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simpleDateFormat.parse(&quot;2020-01-01&quot;);</span><br></pre></td></tr></table></figure>
<p>当程序捕获到异常时，打印相关的信息，并退出整个程序的运行。当程序正确运行后，会打印“所有线<br>程格式化日期成功”。<br>运行程序输出的结果信息如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;pool-1-thread-4&quot; Exception in thread &quot;pool-1-thread-1&quot; </span><br><span class="line">Exception in thread &quot;pool-1-thread-2&quot; </span><br><span class="line">线程：pool-1-thread-7 格式化日期失败 </span><br><span class="line">线程：pool-1-thread-9 格式化日期失败 </span><br><span class="line">线程：pool-1-thread-10 格式化日期失败</span><br><span class="line">Exception in thread &quot;pool-1-thread-3&quot; </span><br><span class="line">Exception in thread &quot;pool-1-thread-5&quot; </span><br><span class="line">Exception in thread &quot;pool-1-thread-6&quot; </span><br><span class="line">线程：pool-1-thread-15 格式化日期失败 </span><br><span class="line">线程：pool-1-thread-21 格式化日期失败 </span><br><span class="line">Exception in thread &quot;pool-1-thread-23&quot; </span><br><span class="line">线程：pool-1-thread-16 格式化日期失败 </span><br><span class="line">线程：pool-1-thread-11 格式化日期失败 java.lang.ArrayIndexOutOfBoundsException </span><br><span class="line">线程：pool-1-thread-27 格式化日期失败 </span><br><span class="line">at java.lang.System.arraycopy(Native Method) </span><br><span class="line">at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:597) at java.lang.StringBuffer.append(StringBuffer.java:367) </span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:191)</span><br><span class="line">线程：pool-1-thread-25 格式 化日期失败 at java.text.DecimalFormat.parse(DecimalFormat.java:2084) </span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)</span><br></pre></td></tr></table></figure>
<p>说明，在高并发下使用SimpleDateFormat类格式化日期时抛出了异常，SimpleDateFormat类不是线程安全的！！！<br>接下来，就看下，SimpleDateFormat类为何不是线程安全的。</p>
<h4 id="SimpleDateFormat类为何不是线程安全的"><a href="#SimpleDateFormat类为何不是线程安全的" class="headerlink" title="SimpleDateFormat类为何不是线程安全的"></a>SimpleDateFormat类为何不是线程安全的</h4><p>通过上面的示例程得知，在高并发环境下SimpleDateFormat类会抛出异常，导致其在高并发环境下不能良好的发挥作用。那么，SimpleDateFormat类为何不是线程安全的呢？<br>这里，看下源码来进一步了解下。通过如下一行代码进入到DateFormat类的源码中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simpleDateFormat.parse(&quot;2020-01-01&quot;);</span><br></pre></td></tr></table></figure>
<p>打开DateFormat类的parse(String)方法，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Date parse(String source) throws ParseException&#123; </span><br><span class="line"></span><br><span class="line">   ParsePosition pos = new ParsePosition(0); </span><br><span class="line">   Date result = parse(source, pos); </span><br><span class="line">   if (pos.index == 0) </span><br><span class="line">   throw new ParseException(&quot;Unparseable date: \&quot;&quot; + source + &quot;\&quot;&quot; , pos.errorIndex); </span><br><span class="line">   return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在DateFormat类的当前parse(String)方法中，再次调用parse(String, ParsePosition)方法来<br>格式化日期，继续查看parse(String, ParsePosition)方法，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract Date parse(String source, ParsePosition pos);</span><br></pre></td></tr></table></figure>

<p>发现parse(String, ParsePosition)方法在DateFormat类中是一个抽象类，具体由子类实现。此时，我<br>们查看此方法的实现，发现此方法正是在SimpleDateFormat类中实现的，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">    public Date parse(String text, ParsePosition pos) &#123;</span><br><span class="line">        checkNegativeNumberExpression();</span><br><span class="line">        int start = pos.index;</span><br><span class="line">        int oldStart = start;</span><br><span class="line">        int textLength = text.length();</span><br><span class="line">        boolean[] ambiguousYear = &#123;false&#125;;</span><br><span class="line">        CalendarBuilder calb = new CalendarBuilder();</span><br><span class="line">        for (int i = 0; i &lt; compiledPattern.length; ) &#123;</span><br><span class="line">            int tag = compiledPattern[i] &gt;&gt;&gt; 8;</span><br><span class="line">            int count = compiledPattern[i++] &amp; 0xff;</span><br><span class="line">            if (count == 255) &#123;</span><br><span class="line">                count = compiledPattern[i++] &lt;&lt; 16;</span><br><span class="line">                count |= compiledPattern[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            switch (tag) &#123;</span><br><span class="line">                case TAG_QUOTE_ASCII_CHAR:</span><br><span class="line">                    if (start &gt;= textLength || text.charAt(start) != (char) count) &#123; //严重破坏了线程的安全性 pos.index = oldStart; //严重破坏了线程的安全性 pos.errorIndex = start; return null; &#125;start++; break; case TAG_QUOTE_CHARS: while (count-- &gt; 0) &#123; if (start &gt;= textLength || text.charAt(start) != compiledPattern[i++]) &#123; //严重破坏了线程的安全性</span><br><span class="line">                        pos.index = oldStart;</span><br><span class="line">                        //严重破坏了线程的安全性 </span><br><span class="line">                        pos.errorIndex = start;</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    start++;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            default:</span><br><span class="line">                boolean obeyCount = false;</span><br><span class="line">                boolean useFollowingMinusSignAsDelimiter = false;</span><br><span class="line">                if (i &lt; compiledPattern.length) &#123;</span><br><span class="line">                    int nextTag = compiledPattern[i] &gt;&gt;&gt; 8;</span><br><span class="line">                    if (!(nextTag == TAG_QUOTE_ASCII_CHAR || nextTag == TAG_QUOTE_CHARS)) &#123;</span><br><span class="line">                        obeyCount = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hasFollowingMinusSign &amp;&amp; (nextTag == TAG_QUOTE_ASCII_CHAR || nextTag == TAG_QUOTE_CHARS)) &#123;</span><br><span class="line">                        int c;</span><br><span class="line">                        if (nextTag == TAG_QUOTE_ASCII_CHAR) &#123;</span><br><span class="line">                            c = compiledPattern[i] &amp; 0xff;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            c = compiledPattern[i + 1];</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (c == minusSign) &#123;</span><br><span class="line">                            useFollowingMinusSignAsDelimiter = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = subParse(text, start, tag, count, obeyCount, ambiguousYear, pos, useFollowingMinusSignAsDelimiter, calb);</span><br><span class="line">                if (start &lt; 0) &#123;</span><br><span class="line">                    //严重破坏了线程的安全性 </span><br><span class="line">                    pos.index = oldStart;</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //严重破坏了线程的安全性 </span><br><span class="line">        pos.index = start;</span><br><span class="line">        Date parsedDate;</span><br><span class="line">        try &#123;</span><br><span class="line">            parsedDate = calb.establish(calendar).getTime();</span><br><span class="line">            if (ambiguousYear[0]) &#123;</span><br><span class="line">                if (parsedDate.before(defaultCenturyStart)) &#123;</span><br><span class="line">                    parsedDate = calb.addYear(100).establish(calendar).getTime();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (</span><br><span class="line">                IllegalArgumentException e) &#123;</span><br><span class="line">            //严重破坏了线程的安全性 </span><br><span class="line">            pos.errorIndex = start;</span><br><span class="line">            //严重破坏了线程的安全性</span><br><span class="line">            pos.index = oldStart;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return parsedDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对SimpleDateFormat类中的parse(String, ParsePosition)方法的分析可以得知，parse(String,<br>ParsePosition)方法中存在几处为ParsePosition类中的索引赋值的操作。<br>一旦将SimpleDateFormat类定义成全局的静态变量，那么SimpleDateFormat类在多个线程间是共享<br>的，这就导致ParsePosition类在多个线程间共享。在高并发场景下，一个线程对ParsePosition类中的<br>索引进行修改，势必会影响到其他线程对ParsePosition类中索引的读操作。这就造成了线程的安全问<br>题。<br>那么，得知了SimpleDateFormat类不是线程安全的，以及造成SimpleDateFormat类不是线程安全的<br>原因，那么如何解决这个问题呢？接下来，我们就一起探讨下如何解决SimpleDateFormat类在高并发<br>场景下的线程安全问题。</p>
<h4 id="解决SimpleDateFormat类的线程安全问题"><a href="#解决SimpleDateFormat类的线程安全问题" class="headerlink" title="解决SimpleDateFormat类的线程安全问题"></a>解决SimpleDateFormat类的线程安全问题</h4><p>解决SimpleDateFormat类在高并发场景下的线程安全问题可以有多种方式,这里，就列举几个常用的方式供参考</p>
<h4 id="1-局部变量法"><a href="#1-局部变量法" class="headerlink" title="1.局部变量法"></a>1.局部变量法</h4><p>最简单的一种方式就是将SimpleDateFormat类对象定义成局部变量，如下所示的代码，将<br>SimpleDateFormat类对象定义在parse(String)方法的上面，即可解决问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDateFormatTest02 &#123;</span><br><span class="line">       //执行总次数</span><br><span class="line">       private static final int EXECUTE_COUNT = 1000;</span><br><span class="line">       //同时运行的线程数量</span><br><span class="line">       private static final int THREAD_COUNT = 20;</span><br><span class="line"></span><br><span class="line">       public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">           final Semaphore semaphore = new Semaphore(THREAD_COUNT);</span><br><span class="line">           final CountDownLatch countDownLatch = new CountDownLatch(EXECUTE_COUNT);</span><br><span class="line">           ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">           for (int i = 0; i &lt; EXECUTE_COUNT; i++) &#123;</span><br><span class="line">             </span><br><span class="line">               executorService.execute(() -&gt; &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       semaphore.acquire();</span><br><span class="line">                       try &#123;</span><br><span class="line">                           SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">                           simpleDateFormat.parse(&quot;2020-01-01&quot;);</span><br><span class="line">                       &#125; catch (ParseException e) &#123;</span><br><span class="line">                           System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                           System.exit(1);</span><br><span class="line">                       &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                           System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                           System.exit(1);</span><br><span class="line">                       &#125;</span><br><span class="line">                       semaphore.release();</span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       System.out.println(&quot;信号量发生错误&quot;);</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                       System.exit(1);</span><br><span class="line">                   &#125;</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125; countDownLatch.await();</span><br><span class="line">           executorService.shutdown();</span><br><span class="line">           System.out.println(&quot;所有线程格式化日期成功&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>此时运行修改后的程序，输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有线程格式化日期成功</span><br></pre></td></tr></table></figure>
<p>当然，这种方式在高并发下会创建大量的SimpleDateFormat类对象，影响程序的性能，所以，这种方式在实际生产环境不太被推荐。</p>
<h4 id="2-synchronized锁方式"><a href="#2-synchronized锁方式" class="headerlink" title="2.synchronized锁方式"></a>2.synchronized锁方式</h4><p>将SimpleDateFormat类对象定义成全局静态变量，此时所有线程共享SimpleDateFormat类对象，此时在调用格式化时间的方法时，对SimpleDateFormat对象进行同步即可，代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDateFormatTest03 &#123;</span><br><span class="line">      //执行总次数 </span><br><span class="line">      private static final int EXECUTE_COUNT = 1000;</span><br><span class="line">      //同时运行的线程数量 </span><br><span class="line">      private static final int THREAD_COUNT = 20;</span><br><span class="line">      //SimpleDateFormat对象 </span><br><span class="line">      private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">      public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">          final Semaphore semaphore = new Semaphore(THREAD_COUNT);</span><br><span class="line">          final CountDownLatch countDownLatch = new CountDownLatch(EXECUTE_COUNT);</span><br><span class="line">          ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">          for (int i = 0; i &lt; EXECUTE_COUNT; i++) &#123;</span><br><span class="line">              executorService.execute(() -&gt; &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      semaphore.acquire();</span><br><span class="line">                      try &#123;</span><br><span class="line">                          synchronized (simpleDateFormat) &#123;</span><br><span class="line">                              simpleDateFormat.parse(&quot;2020-01-01&quot;);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; catch (ParseException e) &#123;</span><br><span class="line">                          System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                          System.exit(1);</span><br><span class="line">                      &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                          System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                          e.printStackTrace();</span><br><span class="line">                          System.exit(1);</span><br><span class="line">                      &#125;</span><br><span class="line">                      semaphore.release();</span><br><span class="line">                  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                      System.out.println(&quot;信号量发生错误&quot;);</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                      System.exit(1);</span><br><span class="line">                  &#125;</span><br><span class="line">                  countDownLatch.countDown();</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          countDownLatch.await();</span><br><span class="line">          executorService.shutdown();</span><br><span class="line">          System.out.println(&quot;所有线程格式化日期成功&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>此时，解决问题的关键代码如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有线程格式化日期成功</span><br></pre></td></tr></table></figure>
<p>需要注意的是，虽然这种方式能够解决SimpleDateFormat类的线程安全问题，但是由于在程序的执行过程中，为SimpleDateFormat类对象加上了synchronized锁，导致同一时刻只能有一个线程执行parse(String)方法。此时，会影响程序的执行性能，在要求高并发的生产环境下，此种方式也是不太推荐使用的。</p>
<h4 id="3-Lock锁方式"><a href="#3-Lock锁方式" class="headerlink" title="3.Lock锁方式"></a>3.Lock锁方式</h4><p>Lock锁方式与synchronized锁方式实现原理相同，都是在高并发下通过JVM的锁机制来保证程序的线程安全。通过Lock锁方式解决问题的代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDateFormatTest04 &#123;</span><br><span class="line">       //执行总次数 </span><br><span class="line">       private static final int EXECUTE_COUNT = 1000;</span><br><span class="line">       //同时运行的线程数量 </span><br><span class="line">       private static final int THREAD_COUNT = 20;</span><br><span class="line">       //SimpleDateFormat对象 </span><br><span class="line">       private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">       //Lock对象 </span><br><span class="line">       private static Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">       public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">           final Semaphore semaphore = new Semaphore(THREAD_COUNT);</span><br><span class="line">           final CountDownLatch countDownLatch = new CountDownLatch(EXECUTE_COUNT);</span><br><span class="line">           ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">           for (int i = 0; i &lt; EXECUTE_COUNT; i++) &#123;</span><br><span class="line">               executorService.execute(() -&gt; &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       semaphore.acquire();</span><br><span class="line">                       try &#123;</span><br><span class="line">                           lock.lock();</span><br><span class="line">                           simpleDateFormat.parse(&quot;2020-01-01&quot;);</span><br><span class="line"></span><br><span class="line">                       &#125; catch (ParseException e) &#123;</span><br><span class="line">                           System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                           System.exit(1);</span><br><span class="line">                       &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                           System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                           System.exit(1);</span><br><span class="line">                       &#125; finally &#123;</span><br><span class="line">                           lock.unlock();</span><br><span class="line">                       &#125;</span><br><span class="line">                       semaphore.release();</span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       System.out.println(&quot;信号量发生错误&quot;);</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                       System.exit(1);</span><br><span class="line">                   &#125;</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">           countDownLatch.await();</span><br><span class="line">           executorService.shutdown();</span><br><span class="line">           System.out.println(&quot;所有线程格式化日期成功&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以得知，首先，定义了一个Lock类型的全局静态变量作为加锁和释放锁的句柄。然后在simpleDateFormat.parse(String)代码之前通过lock.lock()加锁。这里需要注意的一点是：为防止程序抛出异常而导致锁不能被释放，一定要将释放锁的操作放到finally代码块中，如下所示。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有线程格式化日期成功</span><br></pre></td></tr></table></figure>

<p>此种方式同样会影响高并发场景下的性能，不太建议在高并发的生产环境使用。</p>
<h4 id="4-ThreadLocal方式"><a href="#4-ThreadLocal方式" class="headerlink" title="4.ThreadLocal方式"></a>4.ThreadLocal方式</h4><p>使用ThreadLocal存储每个线程拥有的SimpleDateFormat对象的副本，能够有效的避免多线程造成的线程安全问题，使用ThreadLocal解决线程安全问题的代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDateFormatTest05 &#123;</span><br><span class="line">       //执行总次数 </span><br><span class="line">       private static final int EXECUTE_COUNT = 1000;</span><br><span class="line">       //同时运行的线程数量</span><br><span class="line">       private static final int THREAD_COUNT = 20;</span><br><span class="line">       private static ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;DateFormat&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           protected DateFormat initialValue() &#123;</span><br><span class="line">               return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">           final Semaphore semaphore = new Semaphore(THREAD_COUNT);</span><br><span class="line">           final CountDownLatch countDownLatch = new CountDownLatch(EXECUTE_COUNT);</span><br><span class="line">           ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">           for (int i = 0; i &lt; EXECUTE_COUNT; i++) &#123;</span><br><span class="line">               executorService.execute(() -&gt; &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       semaphore.acquire();</span><br><span class="line">                       try &#123;</span><br><span class="line">                           threadLocal.get().parse(&quot;2020-01-01&quot;);</span><br><span class="line">                       &#125; catch (ParseException e) &#123;</span><br><span class="line">                           System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                           System.exit(1);</span><br><span class="line">                       &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                           System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                           System.exit(1);</span><br><span class="line">                       &#125;</span><br><span class="line">                       semaphore.release();</span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       System.out.println(&quot;信号量发生错误&quot;);</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                       System.exit(1);</span><br><span class="line">                   &#125;</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">           countDownLatch.await();</span><br><span class="line">           executorService.shutdown();</span><br><span class="line">           System.out.println(&quot;所有线程格式化日期成功&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以得知，将每个线程使用的SimpleDateFormat副本保存在ThreadLocal中，各个线程在使用时互不干扰，从而解决了线程安全问题。</p>
<p>运行程序，输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有线程格式化日期成功</span><br></pre></td></tr></table></figure>
<p>此种方式运行效率比较高，推荐在高并发业务场景的生产环境使用。<br>另外，使用ThreadLocal也可以写成如下形式的代码，效果是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDateFormatTest06 &#123;</span><br><span class="line">    //执行总次数 </span><br><span class="line">    private static final int EXECUTE_COUNT = 1000;</span><br><span class="line">    //同时运行的线程数量 </span><br><span class="line">    private static final int THREAD_COUNT = 20;</span><br><span class="line">    private static ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;DateFormat&gt;();</span><br><span class="line"></span><br><span class="line">    private static DateFormat getDateFormat() &#123;</span><br><span class="line">        DateFormat dateFormat = threadLocal.get();</span><br><span class="line">        if (dateFormat == null) &#123;</span><br><span class="line">            dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">            threadLocal.set(dateFormat);</span><br><span class="line">        &#125;</span><br><span class="line">        return dateFormat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Semaphore semaphore = new Semaphore(THREAD_COUNT);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(EXECUTE_COUNT);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i = 0; i &lt; EXECUTE_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        getDateFormat().parse(&quot;2020-01-01&quot;);</span><br><span class="line">                    &#125; catch (ParseException e) &#123;</span><br><span class="line">                        System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line"></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        System.exit(1);</span><br><span class="line">                    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                        System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        System.exit(1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(&quot;信号量发生错误&quot;);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    System.exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(&quot;所有线程格式化日期成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-DateTimeFormatter方式"><a href="#5-DateTimeFormatter方式" class="headerlink" title="5.DateTimeFormatter方式"></a>5.DateTimeFormatter方式</h4><p>DateTimeFormatter是Java8提供的新的日期时间API中的类，DateTimeFormatter类是线程安全的，<br>可以在高并发场景下直接使用DateTimeFormatter类来处理日期的格式化操作。代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDateFormatTest07 &#123;</span><br><span class="line">    //执行总次数 </span><br><span class="line">    private static final int EXECUTE_COUNT = 1000;</span><br><span class="line">    //同时运行的线程数量 </span><br><span class="line">    private static final int THREAD_COUNT = 20;</span><br><span class="line">    private static DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Semaphore semaphore = new Semaphore(THREAD_COUNT);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(EXECUTE_COUNT);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i = 0; i &lt; EXECUTE_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        LocalDate.parse(&quot;2020-01-01&quot;, formatter);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        System.exit(1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(&quot;信号量发生错误&quot;);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    System.exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        System.out.println(&quot;所有线程格式化日期成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，DateTimeFormatter类是线程安全的，可以在高并发场景下直接使用DateTimeFormatter类来处理日期的格式化操作。</p>
<p>运行程序，输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有线程格式化日期成功</span><br></pre></td></tr></table></figure>
<p>使用DateTimeFormatter类来处理日期的格式化操作运行效率比较高，推荐在高并发业务场景的生产环境使用.</p>
<h4 id="6-joda-time方式"><a href="#6-joda-time方式" class="headerlink" title="6.joda-time方式"></a>6.joda-time方式</h4><p>joda-time是第三方处理日期时间格式化的类库，是线程安全的。如果使用joda-time来处理日期和时间的格式化，则需要引入第三方类库。这里，我以Maven为例，如下所示引入joda-time库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line"> &lt;groupId&gt;joda-time&lt;/groupId&gt; </span><br><span class="line"> &lt;artifactId&gt;joda-time&lt;/artifactId&gt; </span><br><span class="line"> &lt;version&gt;2.9.9&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>引入joda-time库后，实现的程序代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDateFormatTest08 &#123;</span><br><span class="line">       //执行总次数 </span><br><span class="line">       private static final int EXECUTE_COUNT = 1000;</span><br><span class="line">       //同时运行的线程数量 </span><br><span class="line">       private static final int THREAD_COUNT = 20;</span><br><span class="line">       private static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line"></span><br><span class="line">       public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">           final Semaphore semaphore = new Semaphore(THREAD_COUNT);</span><br><span class="line">           final CountDownLatch countDownLatch = new CountDownLatch(EXECUTE_COUNT);</span><br><span class="line">           ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">           for (int i = 0; i &lt; EXECUTE_COUNT; i++) &#123;</span><br><span class="line">               executorService.execute(() -&gt; &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       semaphore.acquire();</span><br><span class="line">                       try &#123;</span><br><span class="line">                           DateTime.parse(&quot;2020-01-01&quot;, dateTimeFormatter).toDate();</span><br><span class="line">                       &#125; catch (Exception e) &#123;</span><br><span class="line">                           System.out.println(&quot;线程：&quot; + Thread.currentThread().getName() + &quot; 格式化日期失败&quot;);</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                           System.exit(1);</span><br><span class="line">                       &#125;</span><br><span class="line">                       semaphore.release();</span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       System.out.println(&quot;信号量发生错误&quot;);</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                       System.exit(1);</span><br><span class="line">                   &#125;</span><br><span class="line">                   countDownLatch.countDown();</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">           countDownLatch.await();</span><br><span class="line">           executorService.shutdown();</span><br><span class="line">           System.out.println(&quot;所有线程格式化日期成功&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里，需要注意的是：DateTime类是org.joda.time包下的类，DateTimeFormat类和<br>DateTimeFormatter类都是org.joda.time.format包下的类，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import org.joda.time.DateTime; </span><br><span class="line">import org.joda.time.format.DateTimeFormat; </span><br><span class="line">import org.joda.time.format.DateTimeFormatter;</span><br></pre></td></tr></table></figure>
<p>运行程序，输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有线程格式化日期成功</span><br></pre></td></tr></table></figure>

<p>使用joda-time库来处理日期的格式化操作运行效率比较高，推荐在高并发业务场景的生产环境使用。</p>
<p>综上所示：</p>
<p>在解决解决SimpleDateFormat类的线程安全问题的几种方案中，局部变量法由于线程每次执行格式化时间时，都会创建SimpleDateFormat类的对象，这会导致创建大量的SimpleDateFormat对象，浪费运行空间和消耗服务器的性能，因为JVM创建和销毁对象是要耗费性能的。所以，不推荐在高并发要求的生产环境使用。</p>
<p>synchronized锁方式和Lock锁方式在处理问题的本质上是一致的，通过加锁的方式，使同一时刻只能有一个线程执行格式化日期和时间的操作。这种方式虽然减少了SimpleDateFormat对象的创建，但是由于同步锁的存在，导致性能下降，所以，不推荐在高并发要求的生产环境使用。</p>
<p>ThreadLocal通过保存各个线程的SimpleDateFormat类对象的副本，使每个线程在运行时，各自使用自身绑定的SimpleDateFormat对象，互不干扰，执行性能比较高，推荐在高并发的生产环境使用。</p>
<p>DateTimeFormatter是Java8中提供的处理日期和时间的类，DateTimeFormatter类本身就是线程安全的，经压测，DateTimeFormatter类处理日期和时间的性能效果还不错（后文单独写一篇关于高并发下性能压测的文章）。所以，推荐在高并发场景下的生产环境使用。</p>
<p>joda-time是第三方处理日期和时间的类库，线程安全，性能经过高并发的考验，推荐在高并发场景下的生产环境使用。</p>

        <!-- 分类文章 -->
        
      </div>
      <div class="post-content-inner-space">
        
      </div>
   </div>
    <!-- 评论 -->
    
  </div>
</article>
  </div>
</div>



<!-- 如果是home模式的话，不在首页就显示footer，如果不是home模式的话 所有都显示footer -->

  <div class="footer-outer animate__animated  animate__fadeInUp">
    <div class="footer-inner">
    <div class="footer-text">
    <p>Power by <a target="_blank" rel="noopener" href="http://hexo.io/">Liguangling</a> Theme by <a target="_blank" rel="noopener" href="https://github.com/FuShaoLei/hexo-theme-white">White</a></p>

    </div>
    <div class="footer-contact">
    <ul class="footer-ul">
        
        <li class="footer-li">
            <a href="https://github.com/FuShaoLei/hexo-theme-white" target="_blank">
                <i class="ri-github-line"></i>
            </a>
        </li>
        
        <li class="footer-li">
            <a href="mailto:1563250958@qq.com" target="_blank">
                <i class="ri-mail-line"></i>
            </a>
        </li>
        
    </ul>
    </div>
    </div>
</div>






<script src="/js/white.js"></script>



</body>
</html>
